using namespace metal;

struct Vertex
{
	float3 position [[attribute(0)]];
	float3 normal [[attribute(1)]];
	float2 texture_coord [[attribute(2)]];
	float3 weight [[attribute(3)]];
	int3 joint_id [[attribute(4)]];
};

struct RasterizerData
{
	float4 position [[position]];
	float3 world_position;
	float3 normal;
	float2 texture_coord;
};

struct Uniforms
{
	float4x4 model;
	float4x4 view_projection;
	float4x4 joints_matrices[44];
};

// The following matrix inverse code is generated bye SPIRV-Cross
// Returns the determinant of a 2x2 matrix.
static inline __attribute__((always_inline))
float spvDet2x2(float a1, float a2, float b1, float b2)
{
	return a1 * b2 - b1 * a2;
}

// Returns the determinant of a 3x3 matrix.
static inline __attribute__((always_inline))
float spvDet3x3(float a1, float a2, float a3, float b1, float b2, float b3, float c1, float c2, float c3)
{
	return a1 * spvDet2x2(b2, b3, c2, c3) - b1 * spvDet2x2(a2, a3, c2, c3) + c1 * spvDet2x2(a2, a3, b2, b3);
}

// Returns the inverse of a matrix, by using the algorithm of calculating the classical
// adjoint and dividing by the determinant. The contents of the matrix are changed.
static inline __attribute__((always_inline))
float4x4 spvInverse4x4(float4x4 m)
{
	float4x4 adj;	// The adjoint matrix (inverse after dividing by determinant)

	// Create the transpose of the cofactors, as the classical adjoint of the matrix.
	adj[0][0] =  spvDet3x3(m[1][1], m[1][2], m[1][3], m[2][1], m[2][2], m[2][3], m[3][1], m[3][2], m[3][3]);
	adj[0][1] = -spvDet3x3(m[0][1], m[0][2], m[0][3], m[2][1], m[2][2], m[2][3], m[3][1], m[3][2], m[3][3]);
	adj[0][2] =  spvDet3x3(m[0][1], m[0][2], m[0][3], m[1][1], m[1][2], m[1][3], m[3][1], m[3][2], m[3][3]);
	adj[0][3] = -spvDet3x3(m[0][1], m[0][2], m[0][3], m[1][1], m[1][2], m[1][3], m[2][1], m[2][2], m[2][3]);
	adj[1][0] = -spvDet3x3(m[1][0], m[1][2], m[1][3], m[2][0], m[2][2], m[2][3], m[3][0], m[3][2], m[3][3]);
	adj[1][1] =  spvDet3x3(m[0][0], m[0][2], m[0][3], m[2][0], m[2][2], m[2][3], m[3][0], m[3][2], m[3][3]);
	adj[1][2] = -spvDet3x3(m[0][0], m[0][2], m[0][3], m[1][0], m[1][2], m[1][3], m[3][0], m[3][2], m[3][3]);
	adj[1][3] =  spvDet3x3(m[0][0], m[0][2], m[0][3], m[1][0], m[1][2], m[1][3], m[2][0], m[2][2], m[2][3]);
	adj[2][0] =  spvDet3x3(m[1][0], m[1][1], m[1][3], m[2][0], m[2][1], m[2][3], m[3][0], m[3][1], m[3][3]);
	adj[2][1] = -spvDet3x3(m[0][0], m[0][1], m[0][3], m[2][0], m[2][1], m[2][3], m[3][0], m[3][1], m[3][3]);
	adj[2][2] =  spvDet3x3(m[0][0], m[0][1], m[0][3], m[1][0], m[1][1], m[1][3], m[3][0], m[3][1], m[3][3]);
	adj[2][3] = -spvDet3x3(m[0][0], m[0][1], m[0][3], m[1][0], m[1][1], m[1][3], m[2][0], m[2][1], m[2][3]);
	adj[3][0] = -spvDet3x3(m[1][0], m[1][1], m[1][2], m[2][0], m[2][1], m[2][2], m[3][0], m[3][1], m[3][2]);
	adj[3][1] =  spvDet3x3(m[0][0], m[0][1], m[0][2], m[2][0], m[2][1], m[2][2], m[3][0], m[3][1], m[3][2]);
	adj[3][2] = -spvDet3x3(m[0][0], m[0][1], m[0][2], m[1][0], m[1][1], m[1][2], m[3][0], m[3][1], m[3][2]);
	adj[3][3] =  spvDet3x3(m[0][0], m[0][1], m[0][2], m[1][0], m[1][1], m[1][2], m[2][0], m[2][1], m[2][2]);

	// Calculate the determinant as a combination of the cofactors of the first row.
	float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]) + (adj[0][3] * m[3][0]);

	// Divide the classical adjoint matrix by the determinant.
	// If determinant is zero, matrix is not invertable, so leave it unchanged.
	return (det != 0.0f) ? (adj * (1.0f / det)) : m;
}

vertex RasterizerData vertex_main(Vertex vertex_attributes [[stage_in]], constant  Uniforms &uniforms[[buffer(5)]])
{
	RasterizerData vert;

	float4x4 keyframe_transform  =	uniforms.joints_matrices[vertex_attributes.joint_id.x] * vertex_attributes.weight.x +
									uniforms.joints_matrices[vertex_attributes.joint_id.y] * vertex_attributes.weight.y +
									uniforms.joints_matrices[vertex_attributes.joint_id.z] * vertex_attributes.weight.z;

	float4x4 model_animated = uniforms.model * keyframe_transform;
	float4x4 model_inverse  = transpose(spvInverse4x4(uniforms.model));

	vert.world_position = float4(model_animated * float4(vertex_attributes.position, 1.0f)).xyz;
	vert.position		= uniforms.view_projection * float4(vert.world_position, 1.0f);
	vert.normal			= float3x3(model_inverse[0].xyz, model_inverse[1].xyz, model_inverse[2].xyz) * vertex_attributes.normal;
	vert.texture_coord	= vertex_attributes.texture_coord;

	return vert;
}

fragment float4 fragment_main(RasterizerData fragment_input [[stage_in]], texture2d<float> albedo_texture [[texture(0)]])
{
	float3 light_position	= float3(50.0f, 20.0f, 10.0f);
	float3 view_position	= float3(1.0f, 1.0f, 1.0f);
	float3 light_color		= float3(0.9f, 0.9f, 1.0f);
	float3 object_color		= float3(1.0f, 1.0f, 1.0f);

	// ambient
	float ambient_strength	= 0.1f;
	float3 ambient			= ambient_strength * light_color;

	// diffuse
	float3 norm			= normalize(fragment_input.normal);
	float3 light_dir	= normalize(light_position - fragment_input.world_position);
	float diff			= max(dot(norm, light_dir), 0.0);
	float3 diffuse		= diff * light_color;

	// specular
	float specular_strength = 0.5;
	float3 view_dir			= normalize(view_position - fragment_input.world_position);
	float3 reflect_dir		= reflect(-light_dir, norm);
	float spec				= pow(max(dot(view_dir, reflect_dir), 0.0), 32);
	float3 specular			= specular_strength * spec * light_color;
	float3 result			= (ambient + diffuse + specular) * object_color;

	constexpr sampler texture_sampler (mag_filter::linear, min_filter::linear);
	return float4(result, 1.0f) * albedo_texture.sample(texture_sampler, fragment_input.texture_coord);
}
